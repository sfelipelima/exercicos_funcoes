
# Importações principais da aplicação.
# FastAPI gerencia rotas HTTP, HTTPException lida com erros,
# status fornece códigos HTTP padronizados. BaseModel valida
# dados recebidos, Dict tipa o "banco de dados" e uuid4
# gera IDs únicos para cada tarefa criada.


from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel
from typing import Dict
from uuid import uuid4


# Instância principal da API.
# Aqui criamos o objeto FastAPI que será responsável por
# receber requisições e controlar todas as rotas.


app = FastAPI(title="API de Tarefas", version="1.0.0")


# Modelo base de uma tarefa.
# Define os campos obrigatórios e opcionais enviados pelo
# usuário ao criar ou atualizar uma tarefa.


class TarefaBase(BaseModel):
    titulo: str                          # Título da tarefa
    descricao: str = ""                  # Descrição opcional
    concluida: bool = False              # Status inicial (padrão: não concluída)



# Modelo completo da tarefa.
# Inclui o ID gerado automaticamente pela aplicação, além
# dos campos herdados do modelo base.


class Tarefa(TarefaBase):
    id: str                               # Identificador único da tarefa



# "Banco de dados" da aplicação.
# Usamos um dicionário em memória, onde a chave é o ID
# da tarefa e o valor é o objeto Tarefa armazenado.


db_tarefas: Dict[str, Tarefa] = {}


# Rota raiz da aplicação.
# Usada somente para testar se a API está funcionando.
# Retorna uma mensagem simples de confirmação.


@app.get("/")
def read_root():
    return {"mensagem": "API funcionando corretamente!"}


# Rota de criação de tarefas.
# Recebe os dados enviados pelo usuário, valida o título,
# gera um ID único e armazena a tarefa no dicionário.


@app.post("/tarefas", status_code=status.HTTP_201_CREATED, response_model=Tarefa)
def criar_tarefa(tarefa: TarefaBase):

    # Validação: título deve ter ao menos 3 caracteres
    if len(tarefa.titulo.strip()) < 3:
        raise HTTPException(status_code=400, detail="Título inválido. Mínimo de 3 caracteres.")

    # Gera ID único para a nova tarefa
    nova_id = str(uuid4())

    # Cria objeto Tarefa completo
    nova_tarefa = Tarefa(id=nova_id, **tarefa.dict())

    # Salva a tarefa no "banco de dados"
    db_tarefas[nova_id] = nova_tarefa

    return nova_tarefa


# Rota para listar todas as tarefas.
# Retorna uma lista contendo todos os objetos Tarefa
# armazenados no dicionário.


@app.get("/tarefas", response_model=list[Tarefa])
def listar_tarefas():
    return list(db_tarefas.values())



# Rota para obter uma tarefa específica.
# Busca pelo ID informado e retorna a tarefa correspondente,
# caso exista. Se não existir, retorna erro 404.


@app.get("/tarefas/{id}", response_model=Tarefa)
def obter_tarefa(id: str):
    tarefa = db_tarefas.get(id)

    if not tarefa:
        raise HTTPException(status_code=404, detail="Tarefa não encontrada.")

    return tarefa


# Rota para atualizar uma tarefa existente.
# Substitui os valores antigos pelos novos enviados pelo
# usuário, preservando o ID original.


@app.put("/tarefas/{id}", response_model=Tarefa)
def atualizar_tarefa(id: str, tarefa: TarefaBase):

    if id not in db_tarefas:
        raise HTTPException(status_code=404, detail="Tarefa não encontrada.")

    if len(tarefa.titulo.strip()) < 3:
        raise HTTPException(status_code=400, detail="Título inválido. Mínimo de 3 caracteres.")

    tarefa_atualizada = Tarefa(id=id, **tarefa.dict())
    db_tarefas[id] = tarefa_atualizada

    return tarefa_atualizada



# Rota para deletar uma tarefa do banco de dados.
# Remove a tarefa do dicionário e retorna um status 204,
# indicando que a operação foi concluída sem conteúdo.


@app.delete("/tarefas/{id}", status_code=status.HTTP_204_NO_CONTENT)
def deletar_tarefa(id: str):

    if id not in db_tarefas:
        raise HTTPException(status_code=404, detail="Tarefa não encontrada.")

    del db_tarefas[id]



# ===========================================================
#                  TESTES UNITÁRIOS
# ===========================================================


# Importações necessárias para testar as funções da API.
# UUID é usado para validar se IDs gerados são válidos.


import unittest
from uuid import UUID

from main import (
    criar_tarefa,
    listar_tarefas,
    obter_tarefa,
    atualizar_tarefa,
    deletar_tarefa,
    TarefaBase,
    db_tarefas
)



# Classe contendo todos os testes da API.
# Cada função desta classe valida parte do comportamento
# esperado das rotas implementadas.


class TesteAPI(unittest.TestCase):


    # Executado antes de cada teste.
    # Limpa o "banco de dados" para garantir que um teste
    # não interfira no resultado de outro.

    def setUp(self):
        db_tarefas.clear()



    # Testa o processo de criação de tarefas.
    # Verifica se o objeto criado contém os dados corretos,
    # se o ID é válido e se a tarefa foi salva.

    def test_criar_tarefa(self):
        tarefa = criar_tarefa(TarefaBase(titulo="Lavar a louça", descricao="Testando", concluida=False))

        self.assertEqual(tarefa.titulo, "Lavar a louça")
        self.assertEqual(tarefa.descricao, "Testando")
        self.assertFalse(tarefa.concluida)

        UUID(tarefa.id)         # Valida ID

        self.assertEqual(len(db_tarefas), 1)



    # Testa a listagem de tarefas.
    # Após criar duas tarefas, deve retornar exatamente duas.

    def test_listar_tarefas(self):
        criar_tarefa(TarefaBase(titulo="Tarefa A"))
        criar_tarefa(TarefaBase(titulo="Tarefa B"))

        tarefas = listar_tarefas()
        self.assertEqual(len(tarefas), 2)



    # Testa se uma tarefa pode ser recuperada pelo ID.

    def test_obter_tarefa(self):
        criada = criar_tarefa(TarefaBase(titulo="Teste"))

        tarefa = obter_tarefa(criada.id)
        self.assertEqual(tarefa.titulo, "Teste")



    # Testa a atualização de uma tarefa existente.

    def test_atualizar_tarefa(self):
        criada = criar_tarefa(TarefaBase(titulo="Original"))

        atualizada = atualizar_tarefa(
            criada.id,
            TarefaBase(titulo="Atualizada", descricao="Nova desc", concluida=True)
        )

        self.assertEqual(atualizada.titulo, "Atualizada")
        self.assertEqual(atualizada.descricao, "Nova desc")
        self.assertTrue(atualizada.concluida)



    # Testa a exclusão de uma tarefa.
    # Depois de excluir, o dicionário deve ficar vazio.

    def test_deletar_tarefa(self):
        criada = criar_tarefa(TarefaBase(titulo="Excluir"))

        deletar_tarefa(criada.id)

        self.assertEqual(len(db_tarefas), 0)



# Permite rodar os testes ao executar o arquivo diretamente.

if __name__ == "__main__":
    unittest.main()
